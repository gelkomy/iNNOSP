'''
% This function is used to calculate the window time line (Y) with
% overlapping factor = 2
%
% The input  is a numpy array that represents the Original Y timeline 
%
% The output is a data frame that represents Y windows time line
% with classes 0,1,2,3
% /**************************************************************************** 
%  * Job:             Prepare windwos vector (Y)                  * 
%  *                                                                          * 
%  * Generated on:    Mon, May 22, 2017                                       * 
%  * Generated by:    Yousef                                                    * 
%  * Version:         2                                                       * 
%  ****************************************************************************/ 
'''

#from task1_readyY import getY
import numpy as np
import pandas as pd

def getMajorFromVector(a,b):
    countZeros = sum(b[a-3:a+1] == 0);
    countOnes = sum(b[a-3:a+1] == 1);
    countTwos = sum(b[a-3:a+1] == 2);
    countThrees = sum(b[a-3:a+1] == 3);
    myArray = np.array([countZeros,countOnes,countTwos,countThrees]);
    myArray = np.argsort(-myArray)
    return myArray[0]



def getWindows(yTimeLine):
    gapClassValue = 999;
    c1 = 0;
    c2 = 0;
    c3 = 0;
    counterIntervals = 0;
    numberOfWindows = 0;
    numberOfWindowsTotal = 0;
    yTimeLine[len(yTimeLine)-1] = 999;
    
    for i in range(0,len(yTimeLine)):
        if(yTimeLine[i] == gapClassValue):
            if(c1 != c2):
                counterIntervals = counterIntervals + 1 ;
                diffVal = (c2 - c1);
                numberOfWindows = (((diffVal) - np.mod(diffVal,2))/2) -1;
                numberOfWindowsTotal = numberOfWindowsTotal + numberOfWindows;
                c1 = c2;
            c3 = i;
        else:
            c1 = c3;
            c2 = i;
    
    SimulationDataWindows = np.zeros(numberOfWindowsTotal+1)
    SimulationDataWindows_step = 0;
    c1 = 0;
    c2 = 0;
    c3 = 0;
    counterIntervals = 0;
    numberOfWindows = 0;
    numberOfWindowsTotal = 0;
    
    for i in range(0,len(yTimeLine)):
        if(yTimeLine[i] == gapClassValue):
            if(c1 != c2):
                counterIntervals = counterIntervals + 1 ;
                numberOfWindows = (((c2 - c1) - np.mod((c2 - c1),2))/2) -1;
                for j in range(c1+4, c2+1, 2):
                    SimulationDataWindows_step = SimulationDataWindows_step + 1;
                    temp  = yTimeLine;
                    SimulationDataWindows[SimulationDataWindows_step] = getMajorFromVector(j,temp);
                c1 = c2;
            c3 = i;
        else:
            c1 = c3;
            c2 = i;
    w = pd.DataFrame(SimulationDataWindows[1:]);
    w.columns  = ['Y']
    return  w
                         
        